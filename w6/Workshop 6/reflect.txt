Name:        Amirhossein Sabagh
Student#:    152956199
Email:       asabagh@myseneca.ca
Date:        2020-11-08

This week, I learned the logic of deep copying and deep assignment and also learned how to implement them in classes with resources. Classes with resources are classes that include dynamically allocated data members and variables; we call those variables resources. The need for copy constructors and copy assignments becomes clear when assigning and/or copying a resource or a class with resources to another resource or class. Resources need to be independent of the other object's resources; what that means is if we want to change the data in one resource, the resource associated with the other object should stay unchanged and intact. With shallow copying, we do not respect the separate resource allocation for dynamic resources; that is, affecting an object's resource also affects its copy's resource. To prevent this from occurring, we use deep copying and assigning. What copy constructor does is that it allocates new memory for each of the new resources and then copies the data from the source object to a newly created object of the same type. Copy assignment does the same with an existing object. What I did in workshop 6 was that I just declared the copy assignment declare as to perform shallow and deep copying, and then in implementation of the copy constructor, I called the copy assignment with the source object as the left operand and the new object as the right operand.
Another thing I learned this week was how to resize the allocated memory. The workshop's case scenario was to increase the size of double pointer m_numbers by one. What I did to achieve this was to create a temporary double pointer local to the scope of my overload function, allocate memory with the increased size, copy all m_numbers values to it, also copy the argument value to it, then deallocate the m_numbers to release the old allocated memory, and at last set m_numbers to the temporary pointer so from there on it would point to the newly allocated memory.
Last but not least, I learned how to overload insertion and extraction operators and also how to deal with fstream library and its objects. Overloading those operators was exactly like function overloading and it helped me give the code a better look and reduce repetition; by declaring it with a parameter of an object's reference, we can simply do "cout << N" and "addnum >> N". I learned how to create a file object for reading a file with std::ifstream class and the same situation with writing to a file with std::ofstream class. I also received help from some of the member functions like is_open() (for checking the file connection) and close() function (to terminate the connection to the file).