Name:        Amirhossein Sabagh
Student#:    152956199
Email:       asabagh@myseneca.ca
Date:        2020-10-04

This week's workshop helped me to enrich my knowledge of dynamic memory, references, and overloading functions. Allocating dynamic memory came in handy when in the load function, I read the number of accounts I had to deal with and then specified an array with enough room for the members; this way, I helped the program run smoothly by allocating the necessary memory and prevented wasting extra room. Dynamic memory is nothing but an address pointing to the static memory. After we pick the size of the memory, we, with the help of dynamically allocating, declare our array with the specified size. Dynamic memory benefits us in programs that we don't know how many inputs we are going to receive each time; so, instead of setting our array to a safe state like 10000, we use dynamic memory. A vivid example of this event can be seen in this week's workshop, referring to the files 'accounts.csv' and 'accounts_subtest.csv'.
The references are so much easier to work with than pointers. There may be different use cases for them, but in this case that we could reference the structs and variables instead of pointing to them, it made my job easier; pointers can be tricky and maybe a bit hard to apply properly, but references are pretty straight-forward. 
Overloading functions came in handy in the display function. Two functions that want to do the same job but have slightly different definitions don't have to have different identifiers. This purpose can be fulfilled by having functions with the same name but different signatures. The signature in this context is defined as the parameter types or the order of them in a function. We overload functions by changing their parameter types (the thing I did in this workshop) or the order of the parameters. In the DIY section of this lab, the display function wants to display the account records on the screen. The thing is, we have to declare two functions, one for reading data of the file and displaying it as a record, and another one for sorting the data in the file and then displaying all of them. We couldn't do these in one function, but it is also ineffective to have two completely separate functions. By declaring one function as void and one with a parameter of type constant array, we accomplish our goal and also have a better-organized code.
